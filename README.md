# hexagonal-structure
The best implementation of the haxagonal structure I have found

### inspired by [Kat Zien - How Do You Structure Your Go Apps](https://www.youtube.com/watch?v=oL6JBUk6tj0&ab_channel=GopherAcademy)

## GENERATED BY CHAT GPT


Let's say you're building an e-commerce platform that allows vendors to manage their own products and customers to search and purchase them. Here's how you could structure your code using the hexagonal architecture:

Domain layer: This layer contains the core domain logic for the product application. It might include things like creating and updating products, managing product inventory, handling customer orders, and processing payments. You would define interfaces for any external dependencies that the domain layer needs, such as a payment gateway interface or a shipping interface.

Infrastructure layer: This layer contains the implementation of the interfaces defined in the domain layer. For example, you might have a PostgreSQL implementation of the database interface, or a Stripe implementation of the payment gateway interface.

Application layer: This layer contains the business logic for the product application. It acts as the glue between the domain and infrastructure layers, coordinating the interaction between them. For example, the application layer might retrieve product data from the database using the database interface defined in the domain layer, then pass that data to the user interface layer for display.

Interfaces layer: This layer contains the implementation of the user interfaces for the product application. For example, you might have a web interface that allows vendors to manage their products and customers to search and purchase them. You would define interfaces for the application layer to interact with the user interface layer.



#### First Approach
```
├── cmd
│   └── main.go
├── domain
│   ├── customer.go
│   ├── order.go
│   ├── product.go
│   ├── interfaces.go
│   └── vendor.go
├── infrastructure
│   ├── db
│   │   └── postgres
│   │       ├── order.go
│   │       ├── product.go
│   │       └── vendor.go
│   ├── payment
│   │   └── stripe
│   │       └── payment.go
│   └── shipping
│       └── shipping.go
├── interfaces
│   ├── api
│   │   ├── handlers.go
│   │   ├── middleware.go
│   │   └── routes.go
│   └── web
│       ├── handlers.go
│       └── templates
└── vendor
    ├── application
    │   ├── customer_service.go
    │   ├── order_service.go
    │   ├── product_service.go
    │   └── vendor_service.go
    └── config
        └── config.go


```


#### Second approach

```
├── cmd
│   └── main.go
├── application
│   ├── handler
│   │   ├── product_handler.go
│   │   ├── order_handler.go
│   │   └── customer_handler.go
│   └── service
│       ├── product_service.go
│       ├── order_service.go
│       └── customer_service.go
├── domain
│   ├── model
│   │   ├── product.go
│   │   ├── order.go
│   │   └── customer.go
│   ├── repository
│   │   ├── product_repository.go
│   │   ├── order_repository.go
│   │   └── customer_repository.go
│   └── service
│       ├── product_service.go
│       ├── order_service.go
│       └── customer_service.go
└── infrastructure
    ├── database
    │   ├── product_repository.go
    │   ├── order_repository.go
    │   └── customer_repository.go
    ├── payment
    │   └── stripe_payment_gateway.go
    ├── shipping
    │   └── shipping_handler.go
    └── web
        ├── product_handler.go
        ├── order_handler.go
        └── customer_handler.go
```

### Question and Answers with Chat GPT

1. When is it advisable to use domain driven design in golang?

```
Domain-driven design (DDD) is a software development approach that emphasizes the importance of understanding and modeling a business domain to create high-quality software that is closely aligned with the needs of the domain experts and users.

In general, it is advisable to use DDD in Go when developing complex systems with a rich business domain, where there is a clear separation between the domain model and the infrastructure code.

Here are some examples of situations where DDD can be useful in Go:

Developing enterprise applications with complex business rules and requirements.
Building microservices that need to communicate with other services and interact with a database or messaging system.
Developing systems that require a high degree of modularity, scalability, and maintainability.
Creating software that is closely aligned with the business needs of the organization.
Developing software that is used by a large number of users and must be highly available, reliable, and performant.
However, it is important to note that DDD is not a silver bullet and may not be the best approach for every project. It can be time-consuming and expensive to implement, and may not be necessary for smaller or less complex systems. As with any software development approach, it's important to weigh the benefits and drawbacks and choose the approach that best fits the specific needs of the project.
```

2. Are they places where DDD is better than hexagon

```
Hexagonal architecture and Domain-Driven Design (DDD) are not mutually exclusive concepts, as they both focus on structuring software around the domain model.

In fact, some developers see hexagonal architecture as a concrete implementation of DDD principles. Hexagonal architecture provides a way to structure an application so that it is easy to replace or update dependencies, while DDD provides a way to model the domain and encapsulate business logic.

Therefore, there are no hard and fast rules on when to use DDD over hexagonal architecture. Instead, it depends on the requirements of the application and the preferences of the development team.

Both approaches can be applied in Golang (and other programming languages) to build well-structured, maintainable, and testable software.
```
