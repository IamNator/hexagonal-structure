# hexagonal-structure
The best implementation of the haxagonal structure I have found

### inspired by [Kat Zien - How Do You Structure Your Go Apps](https://www.youtube.com/watch?v=oL6JBUk6tj0&ab_channel=GopherAcademy)

## GENERATED BY CHAT GPT


Let's say you're building an e-commerce platform that allows vendors to manage their own products and customers to search and purchase them. Here's how you could structure your code using the hexagonal architecture:

Domain layer: This layer contains the core domain logic for the product application. It might include things like creating and updating products, managing product inventory, handling customer orders, and processing payments. You would define interfaces for any external dependencies that the domain layer needs, such as a payment gateway interface or a shipping interface.

Infrastructure layer: This layer contains the implementation of the interfaces defined in the domain layer. For example, you might have a PostgreSQL implementation of the database interface, or a Stripe implementation of the payment gateway interface.

Application layer: This layer contains the business logic for the product application. It acts as the glue between the domain and infrastructure layers, coordinating the interaction between them. For example, the application layer might retrieve product data from the database using the database interface defined in the domain layer, then pass that data to the user interface layer for display.

Interfaces layer: This layer contains the implementation of the user interfaces for the product application. For example, you might have a web interface that allows vendors to manage their products and customers to search and purchase them. You would define interfaces for the application layer to interact with the user interface layer.



#### First Approach
```
├── cmd
│   └── main.go
├── domain
│   ├── customer.go
│   ├── order.go
│   ├── product.go
│   ├── interfaces.go
│   └── vendor.go
├── infrastructure
│   ├── db
│   │   └── postgres
│   │       ├── order.go
│   │       ├── product.go
│   │       └── vendor.go
│   ├── payment
│   │   └── stripe
│   │       └── payment.go
│   └── shipping
│       └── shipping.go
├── interfaces
│   ├── api
│   │   ├── handlers.go
│   │   ├── middleware.go
│   │   └── routes.go
│   └── web
│       ├── handlers.go
│       └── templates
└── vendor
    ├── application
    │   ├── customer_service.go
    │   ├── order_service.go
    │   ├── product_service.go
    │   └── vendor_service.go
    └── config
        └── config.go


```


#### Second approach

```
├── cmd
│   └── main.go
├── application
│   ├── handler
│   │   ├── product_handler.go
│   │   ├── order_handler.go
│   │   └── customer_handler.go
│   └── service
│       ├── product_service.go
│       ├── order_service.go
│       └── customer_service.go
├── domain
│   ├── model
│   │   ├── product.go
│   │   ├── order.go
│   │   └── customer.go
│   ├── repository
│   │   ├── product_repository.go
│   │   ├── order_repository.go
│   │   └── customer_repository.go
│   └── service
│       ├── product_service.go
│       ├── order_service.go
│       └── customer_service.go
└── infrastructure
    ├── database
    │   ├── product_repository.go
    │   ├── order_repository.go
    │   └── customer_repository.go
    ├── payment
    │   └── stripe_payment_gateway.go
    ├── shipping
    │   └── shipping_handler.go
    └── web
        ├── product_handler.go
        ├── order_handler.go
        └── customer_handler.go
```

### Question and Answers with Chat GPT

1. When is it advisable to use domain driven design in golang?

```
Domain-driven design (DDD) is a software development approach that emphasizes the importance of understanding and modeling a business domain to create high-quality software that is closely aligned with the needs of the domain experts and users.

In general, it is advisable to use DDD in Go when developing complex systems with a rich business domain, where there is a clear separation between the domain model and the infrastructure code.

Here are some examples of situations where DDD can be useful in Go:

i. Developing enterprise applications with complex business rules and requirements.
ii. Building microservices that need to communicate with other services and interact with a database or messaging system.
iii. Developing systems that require a high degree of modularity, scalability, and maintainability.
iv. Creating software that is closely aligned with the business needs of the organization.
v. Developing software that is used by a large number of users and must be highly available, reliable, and performant.
However, it is important to note that DDD is not a silver bullet and may not be the best approach for every project. It can be time-consuming and expensive to implement, and may not be necessary for smaller or less complex systems. As with any software development approach, it's important to weigh the benefits and drawbacks and choose the approach that best fits the specific needs of the project.
```

2. Are they places where DDD is better than hexagon

```
Hexagonal architecture and Domain-Driven Design (DDD) are not mutually exclusive concepts, as they both focus on structuring software around the domain model.

In fact, some developers see hexagonal architecture as a concrete implementation of DDD principles. Hexagonal architecture provides a way to structure an application so that it is easy to replace or update dependencies, while DDD provides a way to model the domain and encapsulate business logic.

Therefore, there are no hard and fast rules on when to use DDD over hexagonal architecture. Instead, it depends on the requirements of the application and the preferences of the development team.

Both approaches can be applied in Golang (and other programming languages) to build well-structured, maintainable, and testable software.
```
3. Give me an example of hexagon structure being used in microservices

Let's say we have an e-commerce application that consists of several microservices, including a product catalog service and a shopping cart service. Each microservice can have its own hexagonal architecture, which allows for a clean separation of concerns between the application logic and the infrastructure.

For example, the product catalog service might have the following directory structure:

```
product-catalog/
├── cmd/
│   └── product-catalog/
│       └── main.go
├── domain/
│   ├── product.go
│   └── product_repository.go
├── infrastructure/
│   └── database/
│       └── mysql/
│           └── product_repository.go
└── usecase/
    └── product_usecase.go
```
In this example, the domain directory contains the domain entities and interfaces that define the core business logic of the product catalog service, while the usecase directory contains the application-specific use cases that implement the business logic using the domain entities and interfaces.

The infrastructure directory contains the implementation details for the service, such as the database implementation in the mysql directory. The cmd directory contains the entry point for the service, which wires up the dependencies and starts the service.

Similarly, the shopping cart service might have its own hexagonal architecture, which would allow for a clean separation of concerns between the application logic and the infrastructure.

Using the hexagonal architecture in a microservices architecture can help to create highly modular and testable services that can be developed and deployed independently of each other. It also allows for a clean separation of concerns between the business logic and the infrastructure, which makes it easier to maintain and scale the application over time.
